:py:mod:`qmat.lagrange`
=======================

.. py:module:: qmat.lagrange

.. autoapi-nested-parse::

   Base module for Barycentric Lagrange Approximation



Module Contents
---------------

.. py:function:: computeFejerRule(n)

   Compute a Fejer rule of the first kind, using DFT (Waldvogel 2006)
   Inspired from quadpy (https://github.com/nschloe/quadpy @Nico_Schl√∂mer)

   :Parameters: **n** (*int*) -- Number of points for the quadrature rule.

   :returns: * **nodes** (*np.1darray(n)*) -- The nodes of the quadrature rule
             * **weights** (*np.1darray(n)*) -- The weights of the quadrature rule.


.. py:class:: LagrangeApproximation(points, weightComputation='AUTO', scaleRef='MAX')




   Class approximating any function on a given set of points using barycentric
   Lagrange interpolation.

   Let note :math:`(t_j)_{0\leq j<n}` the set of points, then any scalar
   function :math:`f` can be approximated by the barycentric formula :

   .. math::
       p(x) =
       \frac{\displaystyle \sum_{j=0}^{n-1}\frac{w_j}{x-x_j}f_j}
       {\displaystyle \sum_{j=0}^{n-1}\frac{w_j}{x-x_j}},

   where :math:`f_j=f(t_j)` and

   .. math::
       w_j = \frac{1}{\prod_{k\neq j}(x_j-x_k)}

   are the barycentric weights.
   The theory and implementation is inspired from [1]_.

   :Parameters: * **points** (*list, tuple or np.1darray*) -- The given interpolation points, no specific scaling, but must be
                  ordered in increasing order.
                * **weightComputation** (*str, optional*) -- Algorithm used to compute the barycentric weights. Can be :

                  - 'FAST' : uses the analytic formula (unstable for large number of points)
                  - 'STABLE' : uses logarithmic difference and scaling of the weights
                  - 'CHEBFUN' : uses the same approach as in the chebfun package

                  The default is 'AUTO' : it tries the 'FAST' algorithm, and if an
                  overflow is detected, it switches to the 'STABLE' algorithm.
                * **scaleRef** (*str, optional*) -- Scaling used in the 'STABLE' algorithm for weight computation.
                  Can be :

                  - 'ZERO' : scaling based on the weight for the value closest to :math:`t=0`.
                  - 'MAX' : scaling based on the maximum weight value.

                  The default is 'MAX'.

   :ivar points: The interpolating points
   :vartype points: np.1darray
   :ivar weights: The associated barycentric weights
   :vartype weights: np.1darray
   :ivar n: The number of points

   :vartype n: int (property)
   :ivar .. [1] Berrut, J. P., & Trefethen, L. N. (2004).: "Barycentric Lagrange interpolation." SIAM review, 46(3), 501-517.


   .. py:property:: n

      The number of points

   .. py:method:: getInterpolationMatrix(times)

      Compute the interpolation matrix for a given set of discrete "time"
      points.

      For instance, if we note :math:`\vec{f}` the vector containing the
      :math:`f_j=f(t_j)` values, and :math:`(\tau_m)_{0\leq m<M}`
      the "time" points where to interpolate.
      Then :math:`I[\vec{f}]`, the vector containing the interpolated
      :math:`f(\tau_m)` values, can be obtained using :

      .. math::
          I[\vec{f}] = P_{Inter} \vec{f},

      where :math:`P_{Inter}` is the interpolation matrix returned by this
      method.

      :Parameters: **times** (*list-like or np.1darray*) -- The discrete "time" points where to interpolate the function.

      :returns: **PInter** -- The interpolation matrix, with :math:`M` rows (size of the **times**
                parameter) and :math:`n` columns.
      :rtype: np.2darray(M, n)


   .. py:method:: getIntegrationMatrix(intervals, numQuad='LEGENDRE_NUMPY')

      Compute the integration matrix for a given set of intervals.

      For instance, if we note :math:`\vec{f}` the vector containing the
      :math:`f_j=f(t_j)` values, and
      :math:`(\tau_{m,left}, \tau_{m,right})_{0\leq m<M}` the different
      interval where the function should be integrated using the barycentric
      interpolant polynomial.
      Then :math:`\Delta[\vec{f}]`, the vector containing the approximations
      of

      .. math::
          \int_{\tau_{m,left}}^{\tau_{m,right}} f(t)dt,

      can be obtained using :

      .. math::
          \Delta[\vec{f}] = P_{Integ} \vec{f},

      where :math:`P_{Integ}` is the interpolation matrix returned by this
      method.

      :Parameters: * **intervals** (*list of pairs*) -- A list of all integration intervals.
                   * **numQuad** (*str, optional*) -- Quadrature rule used to integrate the interpolant barycentric
                     polynomial. Can be :

                     - 'LEGENDRE_NUMPY' : Gauss-Legendre rule from Numpy
                     - 'LEGENDRE_SCIPY' : Gauss-Legendre rule from Scipy
                     - 'FEJER' : internaly implemented Fejer-I rule

                     The default is 'LEGENDRE_NUMPY'.

      :returns: **PInter** -- The integration matrix, with :math:`M` rows (number of intervals)
                and :math:`n` columns.
      :rtype: np.2darray(M, n)



